***内核固件***

[TOC]

# 1. 处理固件
作为一个驱动作者，你可能发现你面对一个设备必须在它能支持工作前下载固件到它里面。硬件市场的许多地方的竞争是如此得强烈，以至于甚至一点用作设备控制固件的EEPROM的成本制造商都不愿意花费。因此固件发布在随硬件一起的一张CD上, 并且操作系统负责传送固件到设备自身。

你可能想解决固件问题使用这样的一个声明：
static char my_firmware[] = { 0x34, 0x78, 0xa4, ... }; 

但是，这个方法几乎肯定是一个错误。将固件编码到一个驱动扩大了驱动的代码，使固件升级困难，并且非常可能产生许可问题。供应商不可能已经发布固件映象在 GPL之下，因此和GPL-许可的代码混合常常是一个错误。为此，包含内嵌固件的驱动不可能被接受到主流内核或者被Linux发布者包含.


## 1.1  内核固件接口

正确的方法是当你需要它时从用户空间获取它。但是，请抵制试图从内核空间直接打开包含固件的文件的诱惑；那是一个易出错的操作，并且它安放了策略(以一个文件名的形式)到内核。相反，正确的方法时使用固件接口，它就是为此而创建的：

```cpp
#include <linux/firmware.h> 
int request_firmware(const struct firmware **fw, char *name,  struct device *device);
```

调用request_firmware要求用户空间定位并提供一个固件映象给内核；我们一会儿看它如何工作的细节。name应当标识需要的固件；正常的用法是供应者提供的固件文件名。某些象my_firmware.bin的名子是典型的。如果固件被成功加载，返回值是 0(负责常用的错误码被返回)，并且fw参数指向一个这些结构：

```cpp
struct firmware { 
    size_t size; 
    u8 *data; 
}; 
```

那个结构包含实际的固件，它现在可被下载到设备中。小心这个固件是来自用户空间的未被检查的数据；你应当在发送它到硬件之前运用任何并且所有的你能够想到的检查来说服你自己它是正确的固件映象。设备固件常常包含标识串，校验和等；在信任数据前全部检查它们。

在你已经发送固件到设备前，你应当释放in-kernel结构，使用：

```cpp
void release_firmware(struct firmware *fw); 
```

因为request_firmware请求用户空间来帮忙，它保证在返回前睡眠。如果你的驱动当它必须请求固件时不在睡眠的位置，异步的替代方法可能要使用：

```cpp
int request_firmware_nowait(struct module *module, char *name, struct device *device, 
        void *context, void (*cont)(const struct firmware *fw, void *context)); 
```

这里额外的参数是moudle（它将一直是THIS_MODULE），context (一个固件子系统不使用的私有数据指针)和cont。如果都进行顺利，request_firmware_nowait 开始固件加载过程并且返回0。在将来某个时间，cont将用加载的结果被调用。如果由于某些原因固件加载失败，fw是NULL。

## 1.2 它如何工作

固件子系统使用sysfs和热插拔机制。当调用request_firmware，一个新目录在/sys/class/firmware下使用你的驱动的名子被创建。那个目录包含3个属性：

- loading 这个属性应当被加载固件的用户空间进程设置为1。当加载进程完成，它应当设为0。写一个值-1到loading会中止固件加载进程。
- data 是一个二进制的接收固件数据自身的属性。在设置loading后，用户空间进程应当写固件到这个属性。
- device 这个属性是一个符号连接到/sys/devices下面的被关联入口项。


一旦创建了sysfs入口项，内核为你的设备产生一个热插拔事件。传递给热插拔处理者的环境包括一个变量FIRMWARE, 它被设置为提供给request_firmware的名子。这个处理者应当定位固件文件，并且拷贝它到内核使用提供的属性。如果这个文件无法找到，处理者应当设置loading 属性为-1。

如果一个固件请求在10秒内没有被服务，内核就放弃并返回一个失败状态给驱动。超时周期可通过sysfs属性/sys/class/firmware/timeout属性改变。

使用request_firmware接口允许你随你的驱动发布设备固件。当正确地集成到热插拔机制，固件加载子系统允许设备简化工作“在盒子之外”显然这是处理问题的最好方法。

但是，请允许我们提出多一条警告：设备固件没有制造商的许可不应当发布。许多制造商会同意在合理的条款下许可它们的固件，如果客气地请求；一些其他的可能不何在。无论如何，在没有许可时拷贝和发布它们的固件是对版权法的破坏并且招致麻烦。