***Linux进程调度器概述***

- 1 背景知识
    - 1.1 什么是调度器
    - 1.2 调度策略
    - 1.3 进程饥饿
- 2 Linux进程的分类
    - 2.1 进程的分类
    - 2.2 实时进程和普通进程
- 3 Linux调度器的演变
- 4 Linux调度器的设计
    - 4.1 Linux进程调度器的框架
        - 4.1.1 2个调度器
        - 4.1.2 6种调度策略
        - 4.1.3 5个调度类
        - 4.1.4 3个调度实体
        - 4.1.5 调度器的就绪队列
        - 4.1.6 调度器整体框架
    - 4.2 进程的调度
    - 4.3 抢占标识TIF_NEED_RESCHED
    - 4.4 内核抢占和用户抢占
    - 4.5 周期性调度器scheduler_tick
    - 4.6 主调度器schedule
        - 4.6.1 主调度器
        - 4.6.2 __schedule完成抢占
    - 4.7 进程上下文且换context_switch
        - 4.7.1 context_switch流程
        - 4.7.2 为什么switch_to需要3个参数
    - 4.8 处理进程优先级
    - 4.9 唤醒抢占

# 1. 背景知识

## 1.1 什么是调度器

通常来说，操作系统是应用程序和可用资源之间的媒介。

典型的资源有内存和物理设备。但是CPU也可以认为是一个资源，调度器可以临时分配一个任务在上面执行（单位是时间片）。调度器使得我们同时执行多个程序成为可能，因此可以与具有各种需求的用户共享CPU。

内核必须提供一种方法，在各个进程之间尽可能公平地共享CPU时间，而同时又要考虑不同的任务优先级。

调度器的一个重要目标是有效地分配CPU时间片，同时提供很好的用户体验。调度器还需要面对一些互相冲突的目标，例如即要为关键实时的任务最小化响应时间、又要最大限度地提供CPU的总体利用率。

调度器的一般原理是，按需分配计算能力，向系统中每个进程提供最大的公平性，或者从另外一个角度上说，它试图确保没有进程被亏待。

## 1.2 调度策略

传统的Unix操作系统调度算法必须实现几个互相冲突的目标：
- 进程响应时间尽可能快
- 后台作业的吞吐量尽可能高
- 尽可能避免进程的饥饿现象
- 低优先级和高优先级进程的需要尽可能的调和

调度策略（scheduling policy）的任务就是决定什么时候以怎样的方式选择一个新进程占用CPU运行。

传统操作系统的调度基于分时（time sharing）技术：多个进程以“时间多路复用”的方式运行，因为CPU的时间被分成片（slice），给每个可运行进程分配一片CPU时间片，当然单处理器在任何给定的时刻只能运行一个进程。

如果当前运行进程的时限（quantum）到期时（即时间片用尽），而该进程还没有运行完毕，进程切换就会发生。

分时依赖于时钟中断，因此对进程是透明的，不需要在任务中插入额外的代码来保证CPU分时。

调度策略也是根据进程的优先级对它们进行分类，有时用复杂的算法求出进程当前的优先级，但最后的结果是相同的：每个进程都有一个值（优先级）相关联，这个值表示把进程如何适当地分配给CPU。

在Linux中，进程的优先级是动态的，调度程序跟踪进程在做什么，并周期性地调整它们的优先级。在这种情况下，在较长的时间间隔内没有任何使用CPU的进程，通过动态地增加它们的优先级来提升它们运行的概率。相对低，对于已经在CPU上运行较长的进程，通过减少它们的优先级来处罚它们。

## 1.3 进程饥饿

进程饥饿，即为Starvation。是指系统不能保证某个进程的等待时间上界，从而使该进程长时间等待，当等待时间给进程推进和响应带来明显影响时，称发生了进程饥饿。当饥饿到一定程度的进程所赋予的任务即使完成也不再具有实际意义时称该进程被饿死。

产生饥饿的主要原因是：
1. 在一个动态系统中，对于每类系统资源，操作系统需要确定一个分配策略，当多个进程同时申请某类资源时，由分配策略确定资源分配给进程的次序。
2. 有时资源分配策略可能是不公平的，即不能保证等待时间上界的存在。在这种情况下，即使系统没有发生死锁，某些进程也可能会长时间等待。

举个例子，当有多个进程需要打印文件时，如果系统分配打印机的策略是最短文件优先，那么长文件的打印任务由于短文件的源源不断而来而被无限推迟，导致最终饥饿甚至饿死。

# 2. Linux进程的分类

## 2.1 进程的分类

当涉及有关调度的问题时，传统上把进程分类为I/O-bound或CPU-bound。

类型 | 别称 | 描述 | 场景
---|---|---|---
I/O-bound | I/O密集型 | 频繁地使用I/O设备，应花费很多时间等待I/O操作的完成 | 数据库，文本编辑器
CPU-bound | CPU密集型 | 花费大量CPU时间进行数值运算 | 图形绘制程序

另外一种分类把进程分为三类：

类型 | 描述 | 示例
---|---|---
交互式（interactive）| 此类进程经常与用户进行交互，因此需要花费很多时间等待键盘和鼠标操作。</br>当接受了用户的输入后，进程必须很快被唤醒，否则用户会感觉系统反应迟钝。 | shell，文本编辑器和图形应用程序
批处理（batch）| 此类进程不必与用户交互，因此进场在后台运行。</br>因为这样的进程不必很快相应，因此常受到调度程序的怠慢。| 编译器、数据库搜索引擎、科学计算
实时（read-time）| 这些进程由很强的调度需求，这样的进程绝不会被低优先级的进程阻塞，</br>而且它们的响应时间要尽可能的短 | 视频音频应用程序，机器人控制

> 注意：前面的两类分类方法在一定程序上相互独立。
>
> 例如，一个批处理进程很有可能是I/O密集型的（如数据库服务器），也有可能是CPU密集型（如图形绘制程序）。

## 2.2 实时进程和普通进程

在Linux中，调度算法可以明确的确认所有实时进程的身份，但是没办法区分交互式程序和批处理程序（从而统称为普通进程），Linux 2.6的调度程序实现了基于进程过去行为的启发式算法，以确定进程应该被当做交互式进程还是批处理进程。当然与批处理进程相比，调度程序有偏爱交互式进行的倾向。

根据进程的不同分类Linux采用不同的调度策略。
- 实时进程：采用FIFO或者Round Robin的调度策略
- 普通进程：则需要区分交互式和批处理式的不同。传统Linux调度器提高交互式应用的优先级，使得它们能更快地被调度。而CFS和RSDL等新的调度器的核心思想是“完全公平”。这个设计理念不仅大大简化了调度器的代码复杂度，还对各种调度需求提供了更完美的支持。

> 注意：Linux将进程和线程调度一视同仁，进程可以看做是单个线程，但是进程可以包含共享一定资源（代码/数据）的多个线程。因此进程调度也包含了线程调度的功能。

Linux进程的调度算法其实经过了很多次的演变，但是其演变主要是针对与普通进程的，因为前面我们提到过根据进程的不同分类，Linux采用不同的调度策略，实时进程和普通进程采用了不同的调度策略，像一般的普通进程还需要启发式的识别批处理进程和交互式进程。

目前实时进程的调度策略比较简单，因为实时进程只要求尽可能快的被响应，基于优先级，每个进程根据它重要程度的不同被赋予不同的优先级，调度器在每次调度时，总选择优先级最高的进程开始执行，低优先级不可能抢占高优先级，因此FIFO或者Round Robin的调度策略即可满足实时进程调度的需求。

但是普通进程的调度策略就比较麻烦了，因为普通进程不能简单的只看优先级，必须公平的占用CPU，否则很容易出现进程的饥饿，这种情况下用户会感觉操作系统很卡，响应总是很慢。因此在Linux调度器的发展历程中经过了多次重大变动，Linux总是希望寻找一个最接近于完美的调度策略来公平快速的调度进程。

此外，系统中进程如果存在实时进程，则实时进程总是在普通进程之前被调度。

# 3. Linux调度器的演变

一开始的调度器的时间复杂度为O(n)的调度算法，这个算法的缺点是当内核中有很多任务时，调度器本身就会耗费不少时间，所以，从Linux 2.6进入了O(1)的调度算法。

然而，Linux是集全球很多程序员的聪明才智而发展起来的超级内核，没有最好，只有更好，在O(1)调度器风光了没几天就又被另一个更优秀的调度器取代了，它就是CFS调度器（Completely Fair Scheduler）。这个也是在Linux 2.6引入的，具体版本为2.6.23，即从此版本开始，内核使用CFS作为它的默认调度器，O(1)调度器被抛弃了，其实CFS的发展也是经历了很多阶段，最早期的楼梯算法（SD），后来逐步对SD算法进行改进衍生出RSDL（Rotating Staircase Deadline Scheduler）这个算法已经是“完全公平”的雏形了，直至CFS是最终被内核采纳的调度器，它从RSDL/SD中吸取了完全公平的思想，不再跟踪进程的睡眠时间，也不再企图区分交互式进程。它将所有的进程都同一对待，这就是公平的含义。CFS的算法和实现都相当简单，众多的测试表明其性能也非常优越。

# 4. Linux调度器的设计

## 4.1 Linux进程调度器的框架

### 4.1.1 2个调度器

可以用两种方法来激活调度：
- 直接调度：比如进程打算睡眠或处于其他原因放弃CPU，即主调度器
- 周期调度：以固定的频率运行，检测是否有比较调度，即周期性调度器

两者又统称通用调度器（Generic Scheduler）或（Core Scheduler）。

并且每个调度器包括两个内容：
1. 调度框架（其实质就是两个函数框架）
2. 调度类

### 4.1.2 6种调度策略

Linux内核目前实现了6中调度策略（即调度算法），用于不同类型的进程进行调度，或者支持某些特殊的功能。

- SCHED\_NORMAL和SCHED\_BATCH调度普通的非实时进程。
- SCHED\_FIFO、SCHED\_RR和SCHED\_DEADLINE调度实时进程。
- SCHED\_IDEL则在系统空闲时调度idle进程。

> idle的运行时机：
>
> idle进程优先级为MAX\_PRIO，即最低优先级。</br>早期版本中，idle是参与调度的，所以将其优先级设为最低，当没有其他进程可以运行时，才会调度执行idle；</br>目前版本中，idle并不在运行队列中参与调度，而是在cpu全局运行队列rq中含idle指针，指向idle进程，在调度器发现运行队列为空的时候，调入执行。

字段 | 描述 | 调度类
---|---|---
SCHED\_NORMAL | 也叫SHCED\_OTHER用于普通进程，通过CFS调度器实现。</br>SCHED\_BATCH用于交互式的IO密集型进程。</br> SCHED\_IDLE是在系统负载很低时使用。 | CFS
SCHED\_BATCH | SCHED\_NORMAL普通进程策略的分化版本。</br>采用分时策略，根据动态优先级（可用nice APIC），分配CPU运算资源。</br>注意：这类进程比实时进程优先级低，在有实时进程存在时，实时进程优先调度。</br>但针对吞吐量优化，允许任务运行时间长，更好地使用cache，适合于批处理的工作。 | CFS
SCHED\_IDLE | 优先级最低，在系统空闲时才跑这类进程。 | CFS-IDLE
SCHED\_FIFO | 先入先出调度算法，相同优先级的任务先到先服务，</br>高优先级的任务可以抢占低优先级的任务。| RT
SCHED\_RR | 轮流调度算法（实时调度策略），采用时间片，</br>相同优先级的任务当用完时间片会被放到队列尾部，以保证公平性，</br>同样，高优先级任务可以抢占低优先级的任务。</br>不同要求的实时任务可以根据需要使用sched\_setscheduler() API来设置策略。 | RT
SCHED\_DEADLINE | 新支持的实时进程调度策略，针对突发计算，且对延迟和完成时间高度敏感的任务适用。</br>基于Earliest Deadline First（EDF）调度算法。|DL

Linux内核实现的6中调度策略：
- SCHED\_NORMAL、SCHED\_BATCH和SCHED\_IDLE使用的是CFS调度类(fair\_sched\_class)
- SCHED\_FIFO和SCHED\_RR使用RT调度类(rt\_sched\_class)
- SCHED\_DEADLINE使用DL调度类(dl\_sched\_class)

### 4.1.3 5个调度类

而依据其调度策略的不同实现了5个调度类，一个调度类可以用一种或多少调度策略调度某一类进程，也可以用于特殊情况或者调度特殊功能的进程。


调度类 | 描述 | 对应调度策略
---|---|---
stop\_sched\_class | 优先级最高的线程，会中断所有线程，且不会被其他任务打断。</br>其作用：</br>1. 发生在cpu\_stop\_cpu\_callback进行cpu之间任务migration</br>2. HOTPULG\_CPU的情况下关闭任务 | NONE
dl\_sched\_class | 采用EDF（最早截止时间优先）调度实时进程 | SCHED\_DEADLINE
rt\_sched\_class | 采用Roound-Robin算法或者FIFO算法调度实时进程</br>具体调度策略由进程的task\_struct->policy指定 | SCHED\_FIFO</br>SCHED\_RR
fair\_sched\_class | 采用CFS算法调度普通进程 | SCHED\_NORMAL</br>SCHED\_BATCH
idle\_sched\_class | 采用CFS算法调度idle进程，每个逻辑处理器的第一个pid=0的线程（swapper）</br>是一个静态线程。调度类属于idle\_sched\_class，所以在ps里面是看不到的。</br>一般运行在开机过程和CPU异常的时候做DUMP使用。 | SCHED\_IDLE

其所属进程的优先级顺序为：
```
stop_sched_class -> dl_sched_class -> rt_sched_class -> fair_sched_class -> idle_sched_class    
```

### 4.1.4 3个调度实体

调度器不限于调度进程，还可以调度更大的实体，比如实现组调度：可用的CPU时间首先在一般的进程组之间分配，接下来分配的时间在组内进行二次分配。

这种一般性要求调度器不直接操作进程，而是处理可调度实体，因此需要一个通用的数据结构描述这个调度实体，即sched\_entity结构，其实实际上就代表了一个调度对象，可以是一个进程，也可以是一个进程组。

Linux中针对当前可调度的实时和非实时进程，定义了类型为sched\_entity的3个调度实体：

调度实体 | 名称 | 描述 | 对应调度类
---|---|---|---
sched\_dl\_entity | DEADLINE调度实体 | 采用EDF算法调度的实时调度实体 | dl\_sched\_class
sched\_rt\_entity | RT调度实体 | 采用Roound-Robin或者FIFO算法调度的实时调度实体 | rt\_sched\_class
sched\_entity | CFS调度实体 | 采用CFS算法调度的普通进程的调度实体 | fair\_sched\_class

### 4.1.5 调度器的就绪队列

另外，对于调度框架及调度类，它们都有自己管理的运行队列，调度框架只识别rq（其实它也不能算是运行队列）。
- cfs调度类：它的运行队列是cfs\_rq（内部使用红黑树组织调度实体）
- rt调度类：它的运行队列是rt\_rq（内部使用优先级bitmap + 双向链表组织调度实体）
- dl调度类：它的运行队列是dl_rq

### 4.1.6 调度器整体框架

本质上，通用调度器是一个分配器，与其他两个组件交互。

**1. 调度器用于判断接下来运行哪个进程**

内核支持不同的调度策略，调度类使得能够以模块化的方法实现这些调度类，即一个类的代码不需要与其他类的代码交互。当调度器被调用时，它会查询调度器类，得知接下来运行哪个进程。

**2. 在选中将要运行的进程之后，必须执行体系结构相关的任务切换**

这需要与CPU紧密交互，每个进程刚好属于某一调度类，各个调度类负责管理所属的进程。通用调度器自身不涉及进程管理，其工作都委托给调度类。

每个进程都属于某个调度类（由字段task\_struct->sched\_class标识），由调度类采用进程对应的调度策略（由字段task\_struct->policy）进行调度，task\_struct也存储了其对应的调度实体（task\_struct->se）。

Linux实现了6种调度策略，依据其调度策略的不同实现了5个调度类，一个调度类可以用一种或多种调度策略调度某一类进程，也可以用于特殊情况或者调度特殊功能的进程。

调度类 | 调度策略 | 调度算法 | 调度实体 | 调度对象
---|---|---|---|---
stop\_sched\_class | none | none | none | cpu\_stop\_cpu\_callback进行cpu之间任务迁移</br>HOTPLUG\_CPU的情况下关闭任务
dl\_sched\_class | SCHED\_DEADLINE | Earliest-Deadline-First算法| sched\_dl\_entity | 采用EDF算法调度实时调度调度实体
rt\_sched\_class | SCHED\_RR</br>SCHED\_FIFO | Roound-Robin算法</br>FIFO算法 | sched\_rt\_entity | 采用RR算法或FIFO算法调度实时调度实体
fair\_sched\_class | SCHED\_NORMAL</br>SCHED\_BATCH| CFS算法 | sched\_entity | 采用CFS算法调度普通调度实体
idle\_sched\_class | SCHED\_IDLE | none | none | cpu空闲时调度idle进程

调度器组成的关系如下图：

![image](./images/0x01.jpg)

- 5种调度器类为什么只有3种调度实体？

这是因为调度实体本质是一个可以被调度的对象，要么是一个进程（Linux中线程本质也是进程），那么是一个进程组，只有dl\_sched\_class、rt\_sched\_class调度的实时进程（组）以及fair\_sched\_class调度的非实时进程（组）是可以被调度的实体对象，而stop\_sched\_class和idle\_sched\_class没有调度实体。

- 为什么采用EDF实时调度需要单独的调度器类， 调度策略和调度实体？

Linux针对实时进程实现了Roound-Robin、FIFO和Earliest-Deadline-First（EDF）算法，SCHED\_RR和SCHED\_FIFO两种调度算法都用rt\_sched\_class调度类和sched\_rt\_entity调度实体描述，而EDF算法却需要单独使用rt\_sched\_class调度类和sched\_dl\_entity调度实体描述。

## 4.2 进程的调度

首先，我们需要搞清楚，什么样的进程会进入调度器进行选择，就是处于TASK\_RUNNING状态的进程，而其他状态下进程都不会进入调度器进行调度。

系统发生调度的时机如下：
1. 调用cond\_resched()时
2. 显示调用schedule()时
3. 从系统调用或者异常中断返回用户空间时
4. 从中断上下文返回用户空间时

当开启内核抢占时，会多出几个调度时机，如下：
5. 在系统调用或者异常中断上下文中调用preempt\_enable()时
6. 在中断上下文中，从中断处理函数返回到可抢占的上下文时（这里是中断下半部，中断上半部实际上关中断，而新的中断只会被等级，由于上半部处理很快，上半部处理完成后才会执行新的中断信号，这样就形成了中断可重入）。

而在系统启动调度器初始化时会初始化一个调度定时器，调度器每隔一定时间执行一个中断，在中断中会对当前运行进程运行时间进行更新，如果进程需要被调度，在调度定时器中断中会设置一个调度标志位，之后从定时器中断返回，因为上面已经提到从中断上下文返回时有调度时机的，在内核源码的汇编代码中所有中断返回处理都必须去判断调度标志位是否设置，如设置则执行schdule()进行调度。

而我们知道实时进程和普通进程是共存的，调度器是怎么协调它们之间的调度呢？其实很简单，每次调度时，会先在实时进程运行队列中查看是否有可运行的实时进程，如果没有，在去普通进程的运行队列找下一个可运行的普通进程，如果也没有，则调度器会使用idle进程进行运行。

系统并不是每时每刻都允许调度发生，当处于硬中断上下文的时候，调度时被系统禁止的，之后硬中断过后才重新允许调度。而对于异常，系统并不会禁止调度，也就是在异常上下文中，系统是有可能发生调度的。

## 4.3 抢占标识TIF_NEED_RESCHED

内核通过need\_resched()检测TIF\_NEED\_RESCHED标识判断是否需要抢占当前进程，内核在thread\_info的flags中设置了一个表示来标志进程是否需要重新调度，内核在即将返回用户空间时通过need\_resched()检查TIF\_NEED\_RESCHED表示，如果置位需要重新调度。

系统中每个进程都有一个特定于体系结构的struct thread\_info结构，用户层程序被调度的时候会检查struct thread\_info中的need\_resched标识TIL\_RESCHED标识来检查自己是否需要被重新调度。

如果内核检查进程的抢占标识被设置，则会在一个关键的时刻，调用调度器来完成调度和抢占的工作。

## 4.4 内核抢占和用户抢占

而根据进程抢占发生的时机，抢占可分为：
- 内核抢占
- 用户抢占

内核抢占就是指一个在内核态运行的进程，可能再执行内核函数期间被另一个进程取代。

用户抢占发生时机：
- 从系统调用返回用户空间
- 从中断（异常）处理程序返回用户空间

内核抢占发生时机：
- 当从中断处理程序在执行，且返回内核空间之前。当一个中断处理例程退出，在返回到内核态时。这是隐式调用schedule()函数，当前任务没有主动放弃CPU使用权，而是被剥夺了CPU使用权。
- 当内核代码在一次具有可抢占的时候，如spin\_unlock\_bh、local\_bh\_enable等，此时内核代码从不可抢占状态变为可抢占状态时。也就是preempt\_count从整数变为0时。这也是隐式的调用schedule()函数。
- 如果内核中任务显式的调用schedule()，任务主动放弃CPU使用权。
- 如果内核中任务阻塞，导致需要调用schedule()函数。任务主动放弃CPU使用权。

内核抢占采用与抢占标识类似的方法实现，Linux内核在thread\_info结构中添加了一个自旋锁标识preempt\_count，称为抢占计数器（preemption counter）。
```c
struct thread_info {
    ......
    
    int         preempt_count;  /* 0 => preemptable,
                           <0 => BUG */
    ......
};
```

preempt\_count | 描述
---|:---
大于0 | 禁止内核抢占，其值标记了使用preempt\_count的临界区的数目
等于0 | 开启内核抢占
小于0 | 锁为负值，内核出现错误

内核提供了一些函数或者宏，用来开启、关闭、检测抢占计数器preempt_count的值，这些通用的函数定义在include/linux/preempt.h。

## 4.5 周期性调度器scheduler_tick

周期性调度器scheduler\_tick由内核时钟中断周期性的触发，周期性调度器以固定的频率激活负责当前进程调度器类的周期性调度方法，以保证系统的并发性，周期性调度器通过调用进程所述调度器类的task\_tick操作完成周期性调度的通知和配置工作，通过resched\_curr函数来通知内核在必要的时间由主调度函数完成真正的调度工作，此种做法称之为延迟调度策略。

## 4.6 主调度器schedule

### 4.6.1 主调度器

schedule就是主调度器的工作函数，在内核中的许多方法使用，如果要将CPU分配给与当前活动进程不同的另一个进程，都会直接调用主调度器函数schedule或者其子函数\_\_schedule。

### 4.6.2 __schedule完成抢占

- 完成一些必要的检查，并设置进程状态，处理进程所在的就绪队列
- 调度全局的pick\_next\_task选择抢占的进程
    - 如果当前cpu上所有的进程都是CFS调度的普通进程，则直接用CFS调度，如果无程序可调度则调度idle进程
    - 否则从优先级最高的调度器类（stop\_sched\_class）开始依次遍历所有调度类的pick\_next\_task函数，选择最优的哪个进程执行
- context\_switch完成进程上下文切换
    - 调用switch\_mm函数，把虚拟内存从一个进程映射到新进程中
    - 调用switch\_to函数，从上一个进程的处理器状态切换到新进程的处理器状态。这包括：保存、恢复栈信息和寄存器信息。

## 4.7 进程上下文且换context_switch

### 4.7.1 context_switch流程

context\_switch其实是一个分配器，它会调用所需要的特定体系结构的方法：
- 调用switch\_mm函数，把虚拟内存从一个进程映射切换到新进程中
    - switch\_mm通过更换task\_struct->mm描述的内存管理上下文，该工作的细节取决于处理器其中包括：加载页表、刷新TLB、向MMU提供新的信息等。
- 调用switch\_to函数，从一个进程的处理器状态切换到新进程的处理器状态。其中包括：保存、恢复栈信息和寄存器信息
    - switch\_to切换处理器寄存器的内容和内核栈（虚拟地址空间的用户部分已经通过switch\_mm变更，其中也包括了用户态的栈，因此switch\_to不需要变更用户栈，只需变更内核栈），此段代码严重依赖体系结构，且代码通常都是用汇编语言编写。

### 4.7.2 为什么switch_to需要3个参数

在新进程被选中执行时，内核恢复到进程被切换出去的点继续执行，此时内核只知道谁之前将新进程抢占了，但是却不知道新进程再次执行时抢占了谁，因此低层的进程切换机制必须将此前执行的进程（即新进程抢占的那个进程）提供给context\_switch。由于控制流会回到函数的中间，因此无法通过普通函数的返回值来完成。因此使用了3个参数，但是逻辑效果仿佛是相同的，仿佛是switch\_to是带有两个参数的函数，而且返回了一个指向此前运行的进程的指针。

```c
switch_to(prev, next, last)

AS

prev = last = switch_to(prev, next);
```
其中返回的prev值并不是做参数的prev值，而是prev被再次调度的时候抢占掉的哪个进程last。

## 4.8 处理进程优先级

内核使用一些简单的数值范围 0 ~ 139表示内部优先级，数值越低，优先级越高。
- 从0 ~ 99的范围专供实时进程使用
- nice的值[-20, 19]则映射到范围100 ~ 139。

优先级有三种：
- 动态优先级
- 静态优先级 
- 实时优先级 

task\_struct采用了三个成员表示进程的优先级：prio和normal\_prio表示动态优先级、static\_prio表示静态优先级、rt\_priority表示实时优先级。

字段 | 描述
---|:---
static\_prio | 用于保存静态优先级，是进程启动时分配的优先级，</br>可以通过nice和sched\_setscheduler系统调用来进行修改，否则在进程运行期间会一直保持恒定。
prio | 保存进程的动态优先级
normal\_prio | 表示基于进程的静态优先级static\_prio和调度策略计算出的优先级。</br>因此即使普通进程和实时进程具有相同的静态优先级，其优先级也是不同的，</br>进程fork时，子进程会继承父进程的普通优先级
rt\_priority | 用于保存实时优先级，实时进程的优先级用于实时优先级rt\_priority来表示

静态优先级static\_prio（普通进程）和实时优先级rt\_priority（实时进程）是计算的起点，因此它们也是进程创建的时候设定好的，我们通过nice修改的就是普通进程的静态优先级static\_prio。

首先通过静态优先级static\_prio计算出普通优先级normal\_prio，该工作可以由normal\_prio函数来完成，该函数定义在kernel/sched/core.c：
```c
static inline int normal_prio(struct task_struct *p)
{
    int prio;

    if (task_has_dl_policy(p))
        prio = MAX_DL_PRIO-1;
    else if (task_has_rt_policy(p))
        prio = MAX_RT_PRIO-1 - p->rt_priority;
    else
        prio = __normal_prio(p);
    return prio;
}
```

内核通过effective\_prio设置动态优先级prio，计算动态优先级的流程如下：
```c
static int effective_prio(struct task_struct *p)
{
    p->normal_prio = normal_prio(p);
    /*
     * If we are RT tasks or we were boosted to RT priority,
     * keep the priority unchanged. Otherwise, update priority
     * to the normal priority:
     */
    if (!rt_prio(p->prio))
        return p->normal_prio;
    return p->prio;
}
```
- 设置进程的普通优先级normal\_prio（实时进程99 - rt\_priority，普通进程为static\_priority）
- 计算进程的动态优先级（实时进程则维持动态优先级的prio不变，普通进程的动态优先级即为其普通优先级）

最后，我们综述一下在针对不同类型进程的计算结果：

进程类型 | 实时优先级</br>rt\_priority | 静态优先级</br>static\_prio | 普通优先级</br>normal\_prio | 动态优先级</br>prio
---|---|---|---|---
EDF调度的实时进程|rt\_priority|不使用|MAX\_DL\_PRIO-1|维持原prio不变
RT调度的实时进程|rt\_priority|不使用|MAX\_RT\_PRIO-1-rt\_priority| 维持原prio不变
普通进程|不使用|static\_prio|static\_prio|static\_prio
优先级提高的普通进程|不使用|static\_prio（改变）| static\_prio|维持原prio不变

## 4.9 唤醒抢占

当在try\_to\_wake\_up/wake\_up\_process和wake\_up\_new\_task中唤醒时，内核使用全局check\_preempt\_curr函数查看是否进程可以抢占当前运行的进程。

每个调度器类都因此应该实现一个check\_preempt\_curr函数，在全局check\_preempt\_curr函数中会调用进程所属调度器类的check\_preempt\_curr方法进行抢占检查，对于完全公平调度器CFS处理的进程，则对应由check\_preempt\_wakeup函数执行该策略。

新唤醒的进程不必一定由完全公平调度器处理，如果新进程是一个实时进程，则会立即请求调度，因为实时进程优先级高，实时进程总会抢占CFS进程。

内核为了实现完全公平，对一些交互式进程有补偿机制，这些交互式进程多数情况下属于睡眠状态，只有在接收到信号以后被幻想，例如vim在接收键盘录入的信号后被唤醒，完成工作后又进入睡眠态，因此我们需要对唤醒的进程做一些补偿。