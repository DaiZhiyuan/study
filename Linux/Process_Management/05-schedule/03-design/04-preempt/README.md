***Linux用户抢占和内核抢占详解(概念, 实现和触发时机)***

[TOC]

# 1. 前景回顾

## 1.1 Linux的调度器组成

### 1.1.1 2个调度器

### 1.1.2 6种调度策略

### 1.1.3 5个调度类

### 1.1.4 3个调度实体

## 1.2 主调度器与内核抢占/用户抢占

### 1.2.1 调度过程中关闭内核抢占

### 1.2.2 调度完成检查need_resched是否需要重新调度

# 2. 非抢占式内核与可抢占式内核

## 2.1 非抢占式内核

## 2.2 抢占式内核

# 3. Linux用户抢占

## 3.1 Linux用户抢占

## 3.2 need_resched标识

## 3.3 用户抢占的发生时机（什么时候需要重新调度need_resched）

# 4. Linux内核抢占

## 4.1 内核抢占的概念

## 4.2 为什么Linux需要内核抢占

## 4.3 内核抢占的发生时机

# 5. 内核抢占的实现

## 5.1 内核如何跟踪它能否被抢占？

## 5.2 内核如何知道是否需要抢占？

### 5.2.1 重新启用内核抢占时使用preempt_schedule检查抢占

### 5.2.2 中断之后返回内核态时通过preempt_schedule_irq触发

### 5.2.3 PREEMPT_ACTIVE标识位和PREEMPT_DISABLE_OFFSET

# 6. 总结

## 6.1 用户抢占

## 6.2 内核抢占