- 1 概述
    - 1.1 概念和差异
        - 1.1.1 中断
        - 1.1.2 异常
        - 1.1.3 比较
    - 1.2 异常的分类
        - 1.2.1 错误类异常
        - 1.2.2 陷阱类异常
        - 1.2.3 中止类异常
    - 1.3 中断/异常列表
    - 1.4 错误代码
    - 1.5 中断/异常优先级
    - 1.6 中断/异常处理

# 1. 概述

为了让CPU能够暂停当前的任务，专去处理突发事件或其他需要处理的任务，人们设计了中断（interrupt）和异常（exception）机制。

在计算机系统中，包括任务切换、时间更新、软件调试在内的很多功能都依靠中断和异常机制实现的。

## 1.1 概念和差异

### 1.1.1 中断

中断通常是由CPU外部的输入输出设备（硬件）所触发的，供外部设备通知CPU有事情需要处理，因此又叫中断请求（Interrupt Request）。中断请求的目的是希望CPU暂时停止执行当前正在执行的程序，转去执行中断请求所对应的中断处理例程（Interrupt Service Routine，简称ISR）。

考虑有些任务是不可打断的，为了防止CPU这时也被打扰，可以通过支持CLI（clear interrupt）指令清除标志寄存器的IF位，以使CPU暂时不受打扰。

但有个例外，这样做只能使CPU不受可屏蔽中断（maskbale interrupt）的打扰，一旦有不可屏蔽中断（Non-Maskable Interrupt，简称为NMI）发生时，CPU仍要立即转去处理。

- 可屏蔽中断：请求信号通常是通过CPU的INTr引脚发给CPU的。
- 不可屏蔽中断：请求信号通常是通过NMI引脚发给CPU的。

在硬件级，中断时由一块专用芯片来管理的，通常称为中断控制器（Interrupt Controller）。它负责分配中断资源和管理各个中断源发出的中断请求。

为了表示各个中断请求，中断管理器通常用IRQ（Interrupt ReQuest）后面加上数字来表示不同路（line）的中断请求信号，比如IRQ0、IRQ1等。

### 1.1.2 异常

与中断不同，异常通常是CPU在执行指令时因为检测到预先定义的某个（或多个）条件而产生的同步事件。

异常的来源有3种：

1. 程序错误：当CPU在执行程序指令时遇到操作数有错误或检测到指令规范中定义的非法情况。
2. 某些特殊指令：这些指令的与其行为就是产生相应的异常。
3. CPU的MAE机制（Machine Check Exception）：当CPU指令指令期间检测到CPU内部或外部的硬件错误。

### 1.1.3 比较

差异：异常来自于CPU本身，是CPU主动产生的。

中断：来自于外部设备，是中断源发起的，CPU是被动的。

很多文献中，把由INT n指令产生的异常称为软件中断（software interrupts），把来自外部设备的中断（包括可屏蔽和不可屏蔽中断）叫外部中断。

> 严格来说，INT n导致的软件中断不是中断而是异常。

## 1.2 异常的分类

根据CPU报告异常的方式和导致异常的指令是否可以安全地重新执行，IA-32 CPU把异常分为3类：
- 错误（Fault）
- 陷阱（Trap）
- 中止（Abort）

### 1.2.1 错误类异常

导致错误类异常的情况通常可以被纠正，而且一旦纠正后，程序可以无损失地恢复执行。
此类异常的一个最常见例子就是内存页错误（page fault）。

当CPU报告错误类异常时，CPU将其状态恢复到导致该异常的指令被执行之前的状态。
而且在CPU转去执行异常处理程序前，在栈中保存的CS和EIP指针是指向导致异常的这条指令。
因此，当异常处理程序返回继续执行时，CPU接下来执行的第一条指令仍然是刚才导致异常的那天指令。
所以，如果导致异常的情况还没有被消除，那么CPU会再次产生异常。

### 1.2.2 陷阱类异常

当CPU报告陷阱类异常时，导致该异常的指令已经执行完毕，压入栈的CS和EIP值（也就是异常处理程序的返回地址）是导致该异常的指令执行后紧接着要执行的下一条指令。
值得说明的是，下一条指令并不一定是与导致异常的指令相邻的下一条。
如果导致异常的指令是跳转指令或函数调用指令，那么下一条指令可能是内存地址不相邻的另一条指令。

导致陷阱类异常的情况通常也是可以无损失地恢复执行的。
比如 INT 3指令导致断点异常就属于陷阱类异常，该异常会使CPU中断到调试器，从调试器返回后，被调试程序可以继续执行。

### 1.2.3 中止类异常

中止类异常主要用来报告严重的错误，比如硬件错误和系统表中包含非法制或不一致状态等。
这类异常不允许恢复继续执行。

原因有二：
1. 当这类异常发生时，CPU并不能总保证报告的导致异常的指令地址是精确的。
2. 出于安全性的考虑，这类异常可能是由于导致该异常的程序执行非法操作导致的，因此就应该强迫其中止退出。



分类 | 报告时间 | 保存的CS和IP指针 | 可恢复性
---|---|---|---
错误（Fault）|开始执行导致异常的指令时|导致异常的那条指令|可以恢复执行
陷阱（Trap）|执行完导致异常的指令时|导致异常的那条指令的下一条指令|可以恢复执行
中止（Abort）|不确定|不确定|不可以

## 1.3 中断/异常列表

在系统中，每个中断或异常都被赋予一个整数ID，称为向量号（Vector No.），CPU和操作系统通过向量号来识别该中断或异常。

IA-32架构规定了0 ~ 31号向量提供CPU设计者使用，32 ~ 255号向量（224个）提供操作系统和计算机生产厂商或其他软硬件开发商使用。


向量号 | 助记符 | 类型 | 描述 | 来源
---|---|---|---|---
0 | #DE | 错误 | 除零错误 | DIV和IDIV指令
1 | #DB | 错误/陷阱 | 调试异常，用于软件调试 | 任何代码或数据引用
2 |   | 中断 | NMI中断 | 不可屏蔽的外部中断
3 | #BP | 陷阱 | 断点 | INT 3指令
4 | #OF | 陷阱 | 溢出 | INTO 指令
5 | #BR | 错误 | 数组越界 | BOUND指令
6 | #UD | 错误 | 无效指令 | UD2指令或任何保留的指令
7 | #NM | 错误 | 数学协处理器不存在或不可用 | 浮点或WAIT/FWAIT指令
8 | #DF | 中止 | 双重错误（Double Fault）| 任何可能产生异常的指令、可屏蔽中断和不可屏蔽中断
9 | #MF | 错误 | 数学协处理器集成到CPU内部后，本异常保留不用| 浮点指令
10 | #TS | 错误 | 无效TSS | 任务切换或访问TSS
11 | #NP | 错误 | 段不存在 | 加载段寄存器或访问系统段
12 | #SS | 错误 | 栈段错误 | 栈操作或加载SS寄存器
13 | #GP | 错误 | 违反了保护模式的规定 | 任何内存引用和保护性检查
14 | #PF | 错误 | 页错误 | 任何内存引用
15 | 保留 |  |  
16 | #MF | 错误 | 浮点错误 | 浮点或WAIT/FWAIT指令
17 | #AC | 错误 | 对齐检查 | 对内存中数据的引用
18 | #MC | 中止 | 机器检查 | 错误码和来源于型号有关
19 | #XF | 错误 | SIMD浮点异常 | SIMD浮点指令
20 ~ 31 | 保留 | | 
32 ~ 255 | 用户定义中断 | 中断 | 可屏蔽中断 | 来自INTR的外部中断或INT n指令

## 1.4 错误代码

CPU在产生某些异常时，会向栈中压入一个32bit的错误代码。

- EXT(External EVent)（bit 0）：如果位1表示外部事件导致的该异常。
- IDT(Descriptor Location)（bit 1）：描述符位置。
    - 如果为1，表示错误码的段选择子索引部分指向的是IDT表中的门描述符；
    - 如果位0，表示索引部分指向的是LDT或GDT中的描述符。
- TI(GDT/LDT)（bit2）：仅当IDT位位0时有效。
    - 当该位为1时，表示索引部分指向的LDT中的段或描述符；
    - 如果为0，表示索引部分指向的是GDT中的描述符。
- 段选择子索引域表示与该错误有关的描述符在IDT、LDT或GDT表中的索引。

## 1.5 中断/异常优先级

如果多个中断请求和异常情况同时发生，CPU应该以什么样的顺序来处理呢？

先处理优先级最高的。


优先级 | 描述
---|---
1（最高）| 硬件重启动和机器检查异常（Machine Check Exception）
2 | 任务切换陷阱
3 | 外部硬件（如芯片组）通过CPU引脚发给CPU的特别干预（intervention）：</br> #FLUSH：强制CPU刷新高速缓存</br> #STPCLK（Stop Clock）：使CPU进入低功耗的Stop-Grant状态</br> #SMI（System Management Interrupt）：切换到系统管理模式（SMM）</br> #INIT：热重启（soft reset）
4 | 上一指令导致的陷阱：</br> 执行INT 3（断点指令）导致的断点</br> 调试陷阱，包括单步执行异常和利用调试寄存器设置的硬件断点
5 | 不可屏蔽中断
6 | 可屏蔽中断
7 | 代码断点错误异常
8 | 取下一条指令时检测到的错误：</br> 违反代码段长度限制</br> 代码内存页错误
9 | 解码下一条指令时检测到的错误：</br> 指令长度大于15字节（包括前缀）</br> 非法操作码</br> 协处理器不可用
10（最低）| 执行指令时检测到的错误：</br> 溢出，当EFlags[OF]=1时执行INTO指令</br> 执行BOUND指令时检测到边界错误</br> 无效的TSS</br> 段不存在</br> 栈异常</br> 一般保护异常</br> 数据页错误</br> 对齐检查异常</br> x87 FPU异常</br> SIMD浮点数异常

## 1.6 中断/异常处理

尽管中断和异常从产生的根源来看有着本质的区别，但是CPU和操作系统是用同一的方式来响应和管理它们的。
中断和异常处理的核心数据结构是中断描述符表（Interrupt Descriptor Table，简称IDT）。
当中断和异常发生时，CPU通过查找IDT表来定义处理例程的地址，然后专区执行该处理例程。
这个查找的过程是在CPU内部进行的。通常，操作系统或BIOS固件在系统初始化阶段就准备好中断处理例程和IDT表，然后把IDT表的位置通过IDTR（IDT Register）寄存器告诉CPU。
IDTR寄存器的长度是48位，高32位是IDT表的基地址（线性地址），低16位是IDT表的边界（以字节位单位的最大偏移，数值位IDT，表数总长度-1）。
只有在0特权级下才可以执行LIDT和SIDT指令，这可以保证IDT表不会被恶意的用户态程序所破坏。
CPU上电或重启后IDTR寄存器会被初始化为如下默认值：
```
基地址 = 0x00000000
边界 = 0xFFFF
```
这恰好与8086 CPU中断向量表（Interrupt Vector Table，简称IVT）的位置相一致。
实模式下IVT表位于物理地址0开始的1KB内存去中，每个IVT表项的长度是4字节，共有256个表项，与x86 CPU的256个中断向量一一对应。

> CPU上电或重启后的初始化状态总是实模式状态。所以IDTR寄存器的初始值页正好符合实模式下中断向量表的要求。