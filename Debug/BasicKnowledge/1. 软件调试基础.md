- 1 概述
    - 1.1 简介
        - 1.1.1 定义
        - 1.1.2 基本过程
    - 1.2 基本特征
        - 1.2.1 难度大
        - 1.2.2 难以估计完成时间
        - 1.2.3 广泛的关联性
    - 1.3 软件调试功能的演进过程
        - 1.3.1 单步执行
        - 1.3.2 断点指令
        - 1.3.3 分支监视
    - 1.4 分类
        - 1.4.1 按调试目标的系统环境分
        - 1.4.2 按目标的执行方式分
        - 1.4.3 按目标代码的执行模式分
        - 1.4.4 按调试器与调试目标的相对位置分
        - 1.4.5 按调试目标的活动性分
    - 1.5 调试技术概览
        - 1.5.1 断点
        - 1.5.2 单步执行
        - 1.5.3 输出调试信息
        - 1.5.4 日志
        - 1.5.5 事件追踪
        - 1.5.6 转储文件
        - 1.5.7 栈回溯
        - 1.5.8 反汇编
        - 1.5.9 观察和修改数据
    - 1.6 CPU的调试支持

# 1. 概述

著名的计算机科学家 Brian Kernighan 曾经说过，软件调试要比编写代码困难一倍，如果你发挥除了最佳才智编写代码，
那么你的智商不足以调试这个代码。

## 1.1 简介

我们首先给出软件调试的解释性定义，而后介绍软件调试的基本过程。

### 1.1.1 定义

什么是软件调试，部不妨从英文的原词software debug说起，debug是在bug一词前面加上de前缀，意思是分离和去除bug。

尽管从字面上，debug的意思是去除bug，但它实际上包含了寻找和定位Bug。

通常将software debug翻译为软件调试，泛指重现软件故障（failure）、定位故障根源，并最终解决软件问题的过程。

### 1.1.2 基本过程

一个完整的软件调试过程，它由以下几个步骤组成：

1. **重现故障**，通常是在用于调试的系统上重复导致故障的步骤，使要解决的问题出现在被调试的系统中。
2. **定位根源**，即综合利用各种调试工具，使用各种调试手段寻找软件故障的根源。
3. **探索和实现解决方案**，根据寻找的故障根源、资源情况、压迫成都等，设计和实现解决方案。
4. **验证方案**，在目标环境中测试方案的有效性，又称为回归（regress）测试。

## 1.2 基本特征

### 1.2.1 难度大

1. 如果把定义软件错误看作是一种特别的搜索问题，那么它通常是个复杂的搜索问题。
2. 为了探索问题的根源，很多时候必须深入到调试模块或系统的底层，研究内部的数据和代码。
3. 因为要在一个较大的问题域内定为错误，所以要求调试者必须由丰富的知识，熟悉问题域内的各个软硬件模块，以及它们之间的协作方式。
4. 很多软件调试任务都有很多特殊性，或者说很难找到两个调试任务是一样的。
5. 软件的大型化、层次的增多、多喝和多喝处理器系统的普及都在增加软件调试的难度。

### 1.2.2 难以估计完成时间

就像侦破一个案件所需要的时间很难确定一样，对于一个软件错误，到底需要多久才能定义到它的根源并解决这个问题是一个很难回答的问题。

### 1.2.3 广泛的关联性

软件调试与计算机的处理器和操作系统都有着很紧密的耦合关系，与软件生产的最主要机器————编译器也息息相关。

## 1.3 软件调试功能的演进过程

### 1.3.1 单步执行

1978年，x86 CPU的第一代8086 CPU问世，在其标志寄存器FLAGS中，专门设计了一个用于软件调试的标志位，叫做TF（Trace Flag）。

TF位主要是提供调试器软件来使用的，当用户需要单步跟踪时，调试器会设置TF位，当CPU执行完一条指令后会检查TF位，如果这个位为1，那么便会产生一个调试异常（INT 1），目的是停止执行当前的程序，中断到调试器中。

### 1.3.2 断点指令

它执行的操作是将AC（Accumulator）寄存器的内容存入地址Y，然后把程序计数器（Program Counter，相当于IP）的值放入AC寄存器，并跳转到Y+1。利用这条指令，调试器可以这样实现断点功能。

当向某一个地址设置断点时，将这一地址及它的值都保存起来，并将这一地址处的内容替换成一条jda指令，指令的操作数Y是设计好的，指向调试器的数据和代码。

当程序执行到断电位置时，系统会执行位于哪里的jda指令，跳转到调试器的代码。
调试器根据AC寄存器的内容知道这个断点发生的位置，找到它所对应的断点记录，然后保存寄存器的内容（上下文），
并打印出存储在位置Y的AC寄存器的内容给调试者，挑事者可以输入内存观察命令或执行其他调试功能，待调试结束后，
输入某一个命令恢复执行。这时调试器需要恢复寄存器的值，将保存的指令恢复回去，然后跳转回去继续执行。

在x86系列CPU中，提供了一条使用异常机制的断点指令，即INT 3，供调试器来设置断点，当CPU执行到这里时，会产生一个异常，跳转到异常处理例程，然后中断到调试器中。

### 1.3.3 分支监视

程序中的分支和跳转指令对于软件的执行流程和执行结果起着关键作用，不恰当的跳转往往是很多软件问题的错误根源。有时跟踪一个程序，是为了检查它的跳转时机和跳转方向。因此，监视和报告程序的分支位置和当时的状态对软件调试是很有意义的。

英特尔P6系列CPU引入了记录分支、中断和异常的功能，以及针对分支设置断点和单步执行。

## 1.4 分类

根据被调试软件的特征、所使用的调试工具，以及软件的运行环境等要素，可以把软件调试分成很多个子类。

### 1.4.1 按调试目标的系统环境分

软件调试所使用的工具和方法与操作系统有着密切的关系。
按照这个标准，可以把调试分为Windows下的软件调试、Linux下的软件调试等。

### 1.4.2 按目标的执行方式分

解析型语言：
    调试使用脚本语言编写的脚本程序的过程称为脚本调试，使用的调试器被称为脚本调试器。

编译型语言：
1. 先编译为中间代码，在运行时动态编译为当前CPU能够执行的目标代码，被称为托管调试。
2. 直接编译成CPU能够执行的目标代码，被称为本地调试（Native Debugging）。

如果希望在同一个调试会话中即调试托管代码，又调试本地代码，这种调试方式称为混合调试（Inter-op Debugging）。

### 1.4.3 按目标代码的执行模式分

根据被调试程序的执行模式，可以把软件调试分为用户态调试（User Mode Debugging）和内核态调试（Kernel Mode Debugging）。

### 1.4.4 按调试器与调试目标的相对位置分

如果被调试程序和调试器在同一个计算机系统中，那么这种调试被称为本机调试（Local Debugging）。

如果调试器和被调试程序分别位于不同的计算机系统中，它们通过以太网或某种介质通信，那么这种调试方式被称为远程调试（Remote Debugging）。

### 1.4.5 按调试目标的活动性分

根据调试目标的活动性，可以把软件调试分为活动目标调试（Live Target Debugging）和转储文件调试（Dump File Debugging）。

## 1.5 调试技术概览

### 1.5.1 断点

断点（breakpoint）是使用调试器进行调试时的最常用调试技术之一。基本思想是在某一个位置设置一个“陷阱”，当CPU执行到这个位置时便停止执行被调试的程序，中断到调试器（break into debugger）中，让挑事者进行分析和调试。
调试者分析结束后，可以让被调试程序恢复执行。

根据断点的设置空间可以把断点分为如下几种：
- **代码断点**：设置在内存空间中的断点，其地址通常为某一段代码的起始处。
- **数据断点**：设置在内存空间中的断点，其地址一般位要监视的变量（数据）的起始地址。
- **I/O断点**：设置在I/O空间的断点，其地址为某一个I/O地址。

根据断点的设置方法：
- **软件断点**：通过向指定的代码位置插入专用的断点指令来实现的，如IA32 CPU的INT 3指令（机器码位0xCC）就是断点指令。
- **硬件断点**：通过设置CPU的调试寄存器来设置的，如IA32 CPU定义了8个调试寄存器DR0~DR7，可以同时设置最多4个硬件断点（对于一个调试会话）。通过调试寄存器可以设置以上3中断点中的任何一种，但是通过断点指令只可以设置代码断点。

> 当中断到调试器时，系统或调试器会将被调试程序的状态保存到一个数据结构中，通常称为执行上下文（context）。中断到调试器后，被调试程序是出于静止状态的，知道用户输入恢复执行命令。

**追踪点（Tracepoint）**：是断点的一种衍生形式。其基本思路是：当设置一个追踪点时，调试器内部会当作特殊的断点来处理。当执行到追踪点时，系统会向调试器报告断点事件，在调试器收到后，会检查内部维护的断点列表，发现目前发生的是追踪点后，便执行这个追踪点所定义的行为，通常是打印提示信息和变量值，然后便直接回复被调试程序执行。因为调试器在执行追踪动作后立刻恢复被调试程序执行的，所以调试者没有感觉到被调试程序中断到调试器的过程，尽管实际上是发生的。

**条件断点（Conditional Breakpoint）**：当用户设置一个条件断点时，调试器实际插入的还是一个无条件断点，在断点命中、调试器收到调试事件后，它会检查这个断点的附加条件。如果条件满足，便中断用户，让用户开始交互调试；如果不满足，那么便立刻恢复被调试程序执行。

### 1.5.2 单步执行

单步执行（Step by step）是最早的调试方式之一。简单来说，就是让应用程序按照某一步骤单位一步一步执行。
根据每次要执行的步骤单位，又分为如下几种：

- 每次执行一条汇编指令，称为汇编语言一级的单步追踪。其实现方法一般是设置CPU的单步执行标志，以IA32 CPU为例，设置CPU标志寄存器的TF（Trap Flag）位，可以让CPU没执行完一条指令便产生一个调试异常（INT 1），中断到调试器。
- 每次执行源代码（如C语言）的一条语句，又称为源代码级的单步追踪。高级语言的单步执行一般也是通过多次汇编一级的单步执行而实现的。当调试器每次收到调试事件时，它会判断程序指针（IP）是否还属于当前的高级语言语句，如果是便再次设置单步执行标志并即刻恢复执行，让CPU在执行一条汇编指令，直到程序指针指向的汇编指令已经属于其他语句。调试器通常是通过符号文件中的源代码行信息来判断程序指针所属于的源代码行的。
- 每次执行一个程序分支，又称为分支到分支单步跟踪。设置IA32 CPU的DbgCtl MSR寄存器的BTF（Branch Trap Flag）标志后，在设置TF标志，便可以让CPU执行到下一个分支指令时触发调试异常。
- 每次执行一个任务（线程），即当指定任务被调度执行时中断到调试器。当IA32 CPU切换到一个新任务时，它会检查任务状态段（TSS）的T标志。如果该标志位1，那么便产生调试异常。

### 1.5.3 输出调试信息

打印和输出调试信息（Debug output/print）是一种简单的软件调试方式。其基本思想就是在程序中编写专门用于输出调试信息的语句，将程序运行的位置、状态和变量取值等信息以文本的形式输出到某一个可以观察到的地方，可以是控制台、窗口、文件或者调试器。

### 1.5.4 日志

与输出调试信息类似，写日志（log）是另一种被调试程序自发的辅助调试手段。其基本思想是在编写程序时加入特定的代码将程序运行的状态信息写到日志文件或数据库中。

### 1.5.5 事件追踪

打印调试信息和日志都是以文本形式来输出和记录信息的，因此不适合处理数据量庞大且速度要求高的情况。
事件追踪机器（Event Trace）正是针对这一需求而设计的，它使用机构化的二进制形式来记录数据，观察时在根据格式文件将信息转化为文本形式，因此适用于监视频繁且复杂的软件过程，比如监视文件访问和网络通信等。

### 1.5.6 转储文件

某些情况下，我们希望将发生问题时的系统状态像拍照片一样永久保存下来，发送或带走后进一步分析和调试，这就是转储文件（Dump File）的基本用途。理想情况下，转储文件是转储时目标程序运行系统的一个快照，包含了当时内存中的所有信息，包括代码和各种数据。

### 1.5.7 栈回溯

目前的主流CPU架构都是使用栈来进行函数调用的，栈上记录了函数的返回地址，因此，通过递归式寻找存放在栈上的函数返回地址，便可以追溯出当前线程的函数调用序列，这便是栈回溯（Stack Backtrace）的基本原理。通过栈回溯产生的函数调用信息被称为Calling Stack。

栈回溯是记录和探索程序执行的极佳方法，使用这种方法，准确且基本不需要额外的开销。

因为从栈上得到的只是函数返回地址（数值），不是函数名称，所以为了便于理解，可以利用调试符号（debug symbol）文件将返回地址翻译成函数名。大多数编译器都支持在编译时生成调试符号。

### 1.5.8 反汇编

所谓反汇编（disassemble），就是将目标代码（指令）翻译为汇编代码。因为汇编代码与机器码有着简单的对应关系，所以反汇编是了解程序目标代码的一种非常直接而有效的方式。有时当我们对高级语言的某一条语句的执行结果百思不得其解时，可以看一下它所对应的汇编代码。

### 1.5.9 观察和修改数据

观察被调试程序的诗句是了解程序内部状态的一种直接的方法。很多调试器提供了观察和修改数据的功能，包含变量和程序的栈及堆等重要数据结构。在调试符号的支持下，可以按照数据类型来显示结构化的数据。

寄存器值代表了程序运行的瞬时状态。观察和修改寄存器的值也是一种常见的调试技术。

## 1.6 CPU的调试支持

以intel CPU为例，其提供了调试支持有:
- INT 3指令：又叫断点指令，当CPU执行到该指令时便会产生断点异常，以便中断到调试器程序。INT 3指令时仍旧断点的实现基础。
- 标志寄存器（EFLAGS）中的TF标志：陷阱标志位，当该标志位1时，CPU每执行完一条指令就产生调试异常，陷阱标志位是单步执行的实现基础。
- 调试寄存器DR0~DR7：用于设置硬件断点和报告调试异常的细节。
- 断点异常（#BP）：当INT 3指令执行时，会导致此异常，CPU转到该异常的处理例程。异常处理例程会进一步将异常分发给调试器软件。
- 调式异常（#DB）：当除INT 3指令以外的调试事件发生时，会导致此异常。
- 任务状态段（TSS）的T标志：任务陷阱标志，当切换到设置了T标志的任务时，CPU会产生调试异常，中断到调试器。
- 分支记录机制：用来记录上一个分支、中断和异常的地址等信息。
- 性能监视：用于监视和优化CPU及软件的执行效率。
- JTAG支持：可以与JTAG调试器一起工作来调试单独靠软件调试器无法调试的问题。